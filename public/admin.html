// === PROCESSOS ===
let pageProc = 1;      // página atual no front
let pagesProc = 1;     // total de páginas (vem do backend)
const limitProc = 20;  // itens por página (precisa bater com o backend)

function updatePagerButtons() {
  const prev = document.getElementById('prevProc');
  const next = document.getElementById('nextProc');
  prev.disabled = pageProc <= 1;
  next.disabled = pageProc >= pagesProc;
}

async function carregarProcessos() {
  const tbody = document.getElementById('tbodyProc');
  tbody.innerHTML = `<tr><td colspan="7">Carregando…</td></tr>`;

  try {
    const params = new URLSearchParams({
      page: pageProc,
      limit: limitProc
    });

    const s  = document.getElementById('fSearch').value.trim();
    const u  = document.getElementById('fUnit').value.trim();
    const c  = document.getElementById('fContract').value.trim();

    if (s) params.set('search', s);
    if (u) params.set('unit', u);
    if (c) {
      params.set('contract', c);
      params.set('contrato', c);
      params.set('contractNumber', c);
      params.set('numeroContrato', c);
    }

    const res = await fetch(`${apiUrl}/api/processes?${params.toString()}`, {
      headers: { 'Content-Type': 'application/json', ...authHeaders() },
      cache: 'no-store'
    });

    if (!res.ok) {
      const msg = await res.text().catch(() => '');
      tbody.innerHTML = `<tr><td colspan="7">Erro ao carregar (${res.status}) ${msg ? ' - ' + msg : ''}</td></tr>`;
      document.getElementById('pageInfoProc').textContent = '';
      pagesProc = 1;
      updatePagerButtons();
      return;
    }

    const json = await res.json();

    // Normalizar resposta
    let items = [];
    let page = pageProc;
    let total = 0;
    let totalPages = 1;

    if (Array.isArray(json)) {
      // Caso extremo: API ainda devolve array simples (sem metadados)
      items = json;
      total = json.length;
      totalPages = Math.max(1, Math.ceil(total / limitProc));
    } else {
      items = json.items || json.data || json.results || json.docs || [];
      page = json.page || json.currentPage || json.pageNumber || pageProc;
      total = json.total || json.count || json.totalDocs || items.length;

      // Se backend mandar totalPages, usa; senão calcula
      totalPages = json.totalPages || json.pages || Math.max(1, Math.ceil(total / limitProc));
    }

    pageProc = page;
    pagesProc = totalPages;
    updatePagerButtons();

    if (!items.length) {
      tbody.innerHTML = `<tr><td colspan="7">Sem resultados.</td></tr>`;
      document.getElementById('pageInfoProc').textContent =
        `Página ${pageProc} de ${pagesProc} — ${total} itens`;
      return;
    }

    // Render da página atual
    tbody.innerHTML = '';
    items.forEach(p => {
      const m = mapProcess(p);
      const tr = document.createElement('tr');
      tr.dataset.sei = m.sei;
      tr.innerHTML = `
        <td>${m.sei}</td>
        <td>${decodePlus(m.assigned)}</td>
        <td>${decodePlus(m.type)}</td>
        <td class="wrap">${decodePlus(m.spec)}</td>
        <td>${m.updated}</td>
        <td>
          <button class="btn btn-sm btn-outline-primary mr-2" data-action="whatsapp" data-sei="${m.sei}">
            <i class="fab fa-whatsapp"></i>
          </button>
          <button class="btn btn-sm btn-outline-secondary" data-action="trello" data-sei="${m.sei}">
            <i class="fab fa-trello"></i>
          </button>
        </td>
        <td>
          <button class="btn btn-sm btn-info" data-action="docs" data-sei="${m.sei}">
            <i class="fas fa-file-upload"></i> Atualizar docs
          </button>
        </td>
      `;
      tbody.appendChild(tr);
    });

    document.getElementById('pageInfoProc').textContent =
      `Página ${pageProc} de ${pagesProc} — ${total} itens`;

  } catch (e) {
    console.error(e);
    tbody.innerHTML = `<tr><td colspan="7">Erro ao carregar (console)</td></tr>`;
    document.getElementById('pageInfoProc').textContent = '';
    pagesProc = 1;
    updatePagerButtons();
  }
}

// Recupera SEI de forma robusta
function getSeiFromButton(btn) {
  const fromBtn = btn?.dataset?.sei;
  if (fromBtn) return fromBtn;
  const tr = btn?.closest('tr');
  const fromRow = tr?.dataset?.sei;
  if (fromRow) return fromRow;
  const firstCell = tr?.querySelector('td');
  return (firstCell?.textContent || '').trim();
}

// Delegação dos botões da tabela
document.getElementById('processosTable').addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-action]');
  if (!btn) return;
  const action = btn.dataset.action;
  const sei = getSeiFromButton(btn);
  if (action === 'whatsapp') {
    alert(`(placeholder) Gerar mensagem WhatsApp para o processo ${sei}`);
  } else if (action === 'trello') {
    alert(`(placeholder) Enviar/atualizar cartão Trello para o processo ${sei}`);
  } else if (action === 'docs') {
    solicitarAtualizacaoDocs(sei);
  }
});

document.getElementById('btnFilter').addEventListener('click', () => {
  pageProc = 1;
  carregarProcessos();
});

document.getElementById('btnClear').addEventListener('click', () => {
  document.getElementById('fSearch').value = '';
  document.getElementById('fUnit').value = '';
  document.getElementById('fContract').value = '';
  pageProc = 1;
  carregarProcessos();
});

document.getElementById('prevProc').addEventListener('click', () => {
  if (pageProc > 1) {
    pageProc--;
    carregarProcessos();
  }
});

document.getElementById('nextProc').addEventListener('click', () => {
  if (pageProc < pagesProc) {
    pageProc++;
    carregarProcessos();
  }
});
